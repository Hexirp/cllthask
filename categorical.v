(*

圏論的にパーサーの性質について考える。

まず、パーサーはプリンターと比べて実装が難しい。
それは、プリンターは一つの適当なソースコードを出力するだけいいのに、
パーサーは失敗する場合を考えなければならないからである。

すなわち、あるパースしたい構造を ``Tree`` と呼ぶと、
``print :: Tree -> String`` となるのに対して、
``parse :: String -> Maybe Tree`` となるためだ。

*)

Definition tree : Type := nat.

Definition print : tree -> nat := mult 2.

(*

``print`` と ``parse`` が満たすべき性質を考えよう。

``parse . print === id`` は成り立たないかもしれない。
例えば、普通、関数には使っていけない文字があるが、その関数名は
``Tree`` 内で表現されるときは String であることがあるから。
即ち、String で表現された関数名に改行が含まれていたら、
それを表示したものを解文するとおそらくエラーになる。

しかし、``parse . print . parse === parse`` は成り立つべきだ。
解文によって生成された ``Tree`` は正しいものであるべきだからだ。

``print . parse === id`` は成り立たないかもしれない。
細かい字下げの違いが解文の時に消えてしまうことがあり得る。

しかし、``print . parse . print === print`` は成り立つべきだ。
一度表示したものは形が整えられているからだ。

このような構造を圏論では何というべきであろうか？

単純に、これらの関数を射であると考えよう。

*)
